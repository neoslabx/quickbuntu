#!/usr/bin/env bash

# VERSION - Human-readable script version string.
# Update this when making user-visible changes.
VERSION="v1.4"

# DRYRUN - When set to "1", perform a dry run only (no file changes).
# Shows moves/deletions without modifying files.
DRYRUN=0

# TARGETDIR - Directory containing media to process.
# Default: current directory.
TARGETDIR="."

# RECURSIVE - When set to "1", scan subdirectories recursively.
# When "0", only scan TARGETDIR (non-recursive).
RECURSIVE=0

# KEEPDUPLICATE - When "1", move duplicates to ".duplicates" instead of deleting.
# When "0", delete duplicates (keep the first occurrence).
KEEPDUPLICATE=0

# DATEFALLBACK - Fallback date (YYYYMMDD) if none found and mtime resolves oddly.
# Default: current date at runtime; can be overridden here if desired.
DATEFALLBACK=""

# HASHCMD - Will be detected automatically (sha256sum or shasum -a 256).
# Leave empty; the script resolves it at runtime.
HASHCMD=""

# OUTDIR - Optional output directory for renamed files.
# When set, all renamed media are placed here (duplicates handled accordingly).
OUTDIR=""

# Timeouts (seconds) and tools
# TIMEOUTMETA - max seconds for exiftool metadata read
# TIMEOUTHASH - max seconds for sha256 computation
# TIMEOUTBIN  - 'timeout' command if available (GNU coreutils)
TIMEOUTMETA=10
TIMEOUTHASH=60
TIMEOUTBIN=""

# ALLOWEDIMGEXT - Space-separated, case-insensitive list of image extensions.
# Used to classify IMG- prefix.
ALLOWEDIMGEXT="jpg jpeg png gif tif tiff bmp webp heic heif"

# ALLOWEDVIDEXT - Space-separated, case-insensitive list of video extensions.
# Used to classify VID- prefix.
ALLOWEDVIDEXT="mp4 mov m4v avi mkv 3gp webm"

# GLOBAL COUNTERS (initialized in main) - Associative arrays require bash >=4
# COUNTERS - per (prefix+date) counter for sequence numbers
# HASHSEED - hash->kept_path to detect duplicates
declare -A COUNTERS
declare -A HASHSEED

# Track max sequence discovered on-disk per key (prefix+date)
declare -A MAXSEQ

# SUMMARY counters
PROCESSED=0
RENAMEDCK=0
RENAMED=0
SKIPALREADY=0
DUPESDELETED=0
DUPESMOVED=0
ERRORS=0
TIMEOUTSMETA=0
TIMEOUTSHASH=0

# Function say()
# Simple echo wrapper with -e for consistent formatting
# Return: <string>
say()
{
    echo -e "$@"
}

# Function linebreak()
# Print a well formatted line break
# Return: <string>
linebreak() 
{
    printf '%0.s-' {1..100}; echo
}

# Function showbanner()
# Print a startup banner summarizing configuration
# Return: void
showbanner()
{
    clear 2>/dev/null || true
    printf '%0.s=' {1..60}; echo
    say "Media Rename & Dedupe $VERSION"
    say "Mediasane $VERSION - Linux Medias Organizer Script"
    printf '%0.s=' {1..60}; echo

    say "[+] Directory: ${TARGETDIR}"
    say "[+] Mode: $([[ $DRYRUN -eq 1 ]] && echo 'dry-run' || echo 'real execution')"

    [[ $RECURSIVE -eq 1 ]] && say "[+] Recursion: enabled" || say "[+] Recursion: disabled"
    [[ $KEEPDUPLICATE -eq 1 ]] && say "[+] Duplicates: moved to .duplicates" || say "[+] Duplicates: deleted"
    [[ -n "$OUTDIR" ]] && say "[+] Output dir: $OUTDIR"
    [[ -n "$DATEFALLBACK" ]] && say "[+] Fallback date: $DATEFALLBACK"
    sleep 1s
}

# Function showusage()
# Print usage and options for the script
# Return: <string>
showusage()
{
    printf '%0.s=' {1..60}; echo
    say "Usage Menu"
    printf '%0.s=' {1..60}; echo

    say "Description:"
    say "  Renames media files (images/videos) to:"
    say "    IMG-YYYYMMDD-00001.jpg  or  VID-YYYYMMDD-00001.mp4"
    say
    say "Syntax:"
    say "  mediasane [options]"
    say
    say "Options:"
    say "  --dir PATH               Set target directory (default: .)"
    say "  --recursive              Recurse into subdirectories"
    say "  --dry-run                Preview without changing anything"
    say "  --keep-dupes             Move duplicates to ./.duplicates instead of deleting"
    say "  --fallback YYYYMMDD      Force fallback date if none can be derived"
    say "  --outdir PATH            Write renamed media into specified output directory"
    say "  --meta-timeout SEC       Override metadata timeout (default: 10)"
    say "  --hash-timeout SEC       Override hash timeout (default: 60)"
    say
    say "Help/Info:"
    say "  -h, --help, usage        Show this menu and exit."
    say "  --version                Print version and exit."
    say
    say "Examples:"
    say "  mediasane --dir /path/to/folder"
    say "  mediasane --dir . --recursive --dry-run"
    say "  mediasane --dir ./input --outdir ./renamed"
}

# Function showsummary()
# Print summary at end of execution
# Return: void
showsummary()
{
    printf '%0.s=' {1..60}; echo
    say "SUMMARY"
    printf '%0.s=' {1..60}; echo
    say "Processed:     $PROCESSED"
    say "Renamed:       $RENAMED"
    say "Skipped same:  $SKIPALREADY"
    say "Dupes deleted: $DUPESDELETED"
    say "Dupes moved:   $DUPESMOVED"
    say "Errors:        $ERRORS"
    say "Timeouts meta: $TIMEOUTSMETA"
    say "Timeouts hash: $TIMEOUTSHASH"
    printf '%0.s=' {1..60}; echo
}

# Function argsparser()
# Parse command-line arguments and set globals
# Return: void
argsparser()
{
    while [[ $# -gt 0 ]];
    do
        case "$1" in
            --dir) TARGETDIR="${2:-.}"; shift 2 ;;
            --recursive) RECURSIVE=1; shift ;;
            --dry-run) DRYRUN=1; shift ;;
            --keep-dupes) KEEPDUPLICATE=1; shift ;;
            --fallback) DATEFALLBACK="${2:-}"; shift 2 ;;
            --outdir) OUTDIR="${2:-}"; shift 2 ;;
            --meta-timeout) TIMEOUTMETA="${2:-10}"; shift 2 ;;
            --hash-timeout) TIMEOUTHASH="${2:-60}"; shift 2 ;;
            -h|--help|usage) showusage; exit 0 ;;
            --version) echo "media_rename_dedupe $VERSION"; exit 0 ;;
            *) say "[!] Unknown argument: $1"; echo; showusage; exit 1 ;;
        esac
    done
}

# Function reqdeps()
# Ensure required tools exist (exiftool + hash command)
# Return: <boolean>
reqdeps()
{
    if ! command -v exiftool >/dev/null 2>&1;
    then
        say "ERROR: exiftool is required. Install it (e.g., sudo apt install exiftool)."
        return 1
    fi

    if command -v sha256sum >/dev/null 2>&1;
    then
        HASHCMD="sha256sum"
    elif command -v shasum >/dev/null 2>&1;
    then
        HASHCMD="shasum -a 256"
    else
        say "ERROR: Need sha256sum or shasum for duplicate detection."
        return 1
    fi

    if command -v timeout >/dev/null 2>&1; then
        TIMEOUTBIN="timeout"
    else
        TIMEOUTBIN=""  # we’ll run without hard timeout if unavailable
    fi

    return 0
}

# Function lower()
# Print lowercase version of the input string
# Return: <string>
lower()
{
    awk '{print tolower($0)}'
}

# Function imgext()
# Check if extension belongs to supported image types
# Return: <boolean>
imgext()
{
    local extlc="$1"
    for e in $ALLOWEDIMGEXT;
    do
        [[ "$extlc" == "$e" ]] && return 0
    done
    return 1
}

# Function vidext()
# Check if extension belongs to supported video types
# Return: <boolean>
vidext()
{
    local extlc="$1"
    for e in $ALLOWEDVIDEXT;
    do
        [[ "$extlc" == "$e" ]] && return 0
    done
    return 1
}

# Function mediatype()
# Classify media as "image", "video", or "other" based on extension
# Return: <string>
mediatype()
{
    local extlc="$1"
    if imgext "$extlc";
    then
        echo "image"
    elif vidext "$extlc";
     then
        echo "video"
    else
        echo "other"
    fi
}

# Function safemove()
# Move/rename a file (respects DRYRUN)
# Return: <cmd>
safemove()
{
    local src="$1" dst="$2"
    if [[ $DRYRUN -eq 1 ]];
    then
        say "[DRY-RUN] mv -- \"$src\" \"$dst\""
    else
        if mv -- "$src" "$dst"; then
            return 0
        else
            say "ERROR: mv failed: $src -> $dst"
            ERRORS=$((ERRORS+1))
            return 1
        fi
    fi
}

# Function ensuredir()
# Create directory if missing (respects DRYRUN)
# Return: <cmd>
ensuredir()
{
    local d="$1"
    [[ -d "$d" ]] && return 0
    if [[ $DRYRUN -eq 1 ]];
    then
        say "[DRY-RUN] mkdir -p -- \"$d\""
    else
        mkdir -p -- "$d" || { say "ERROR: cannot create dir $d"; ERRORS=$((ERRORS+1)); return 1; }
    fi
}

# Function safedelete()
# Remove a file (respects DRYRUN)
# Return: <cmd>
safedelete()
{
    local f="$1"
    if [[ $DRYRUN -eq 1 ]];
    then
        say "[DRY-RUN] rm -- \"$f\""
    else
        if rm -- "$f"; then :; else
            say "ERROR: rm failed: $f"
            ERRORS=$((ERRORS+1))
        fi
    fi
}

# Function runtimeout()
# Helper to run a command with timeout if available
# Return: <seconds> <cmd...>
runtimeout() 
{
    local secs="$1"; shift
    if [[ -n "$TIMEOUTBIN" && "$secs" -gt 0 ]];
    then
        $TIMEOUTBIN "$secs" "$@"
        return $?
    else
        "$@"
        return $?
    fi
}

# Function computehash()
# Compute SHA-256 hash for a path into stdout
# Return: <hash>
computehash()
{
    local f="$1"
    local out
    if ! out="$(runtimeout "$TIMEOUTHASH" $HASHCMD -- "$f")"; then
        say "[TIMEOUT] hash on \"$f\" — falling back to size@mtime weak key"
        TIMEOUTSHASH=$((TIMEOUTSHASH+1))
        # Weak key fallback: size@mtime to still dedupe within this run
        local sz mt
        if stat --version >/dev/null 2>&1; then
            sz="$(stat -c %s -- "$f")"
        else
            sz="$(stat -f %z -- "$f")"
        fi
        mt="$(epochtime "$f")"
        echo "weak-${sz}@${mt}"
        return 0
    fi
    echo "$out" | awk '{print $1}'
}

# Function epochtime()
# Get file mtime in epoch seconds (portable Linux/macOS)
# Return: <epoch>
epochtime()
{
    local f="$1"
    if stat --version >/dev/null 2>&1;
    then
        stat -c %Y -- "$f"
    else
        stat -f %m -- "$f"
    fi
}

# Function epochdate()
# Convert epoch seconds to YYYYMMDD
# Return: <YYYYMMDD>
epochdate()
{
    local epoch="$1"
    if date -r 0 >/dev/null 2>&1;
    then
        date -r "$epoch" +%Y%m%d
    else
        date -d "@$epoch" +%Y%m%d
    fi
}

# Function currentdate()
# Return today's date as YYYYMMDD
# Return: <YYYYMMDD>
currentdate()
{
    date +%Y%m%d
}

# Function dateprefix()
# If filename starts with 8 digits, return YYYYMMDD; else empty
# Return: <YYYYMMDD|string-empty>
dateprefix()
{
    local base="$1"
    if [[ "$base" =~ ^([0-9]{8}) ]];
    then
        echo "${BASHREMATCH[1]}"
    else
        echo ""
    fi
}

# Function datemeta()
# Attempt to read a date from metadata using exiftool (formatted YYYYMMDD)
# Return: <YYYYMMDD|string-empty>
datemeta()
{
    local f="$1"
    local v=""
    if v="$(runtimeout "$TIMEOUTMETA" exiftool -s -S -q -q -m -api LargeFileSupport=1 -fast2 -d '%Y%m%d' -DateTimeOriginal -CreateDate -MediaCreateDate -FileModifyDate -- "$f" 2>/dev/null | head -n1)";
    then
        [[ "$v" =~ ^[0-9]{8}$ ]] && echo "$v" || echo ""
    else
        say "[TIMEOUT] exiftool on \"$f\" — using mtime/fallback"
        TIMEOUTSMETA=$((TIMEOUTSMETA+1))
        echo ""
    fi
}

# Function datemtime()
# Derive date from file modification time (YYYYMMDD)
# Return: <YYYYMMDD>
datemtime()
{
    local f="$1"
    local ep
    ep="$(epochtime "$f")"
    epochdate "$ep"
}

# Function resolvseg()
# Resolve the date following precedence rules; fallback to DATEFALLBACK/today
# Return: <YYYYMMDD>
resolvseg()
{
    local path="$1"
    local name base ext
    name="$(basename -- "$path")"
    base="${name%.*}"

    local d=""
    d="$(dateprefix "$base")"
    if [[ -z "$d" ]];
    then
        d="$(datemeta "$path")"
    fi
    if [[ -z "$d" ]];
    then
        d="$(datemtime "$path")"
    fi
    if [[ -z "$d" ]];
    then
        d="${DATEFALLBACK:-$(currentdate)}"
    fi

    echo "$d"
}

# Function nextseq()
# Increment and return a zero-padded sequence for a (prefix+date) key
# Return: <00001>
nextseq()
{
    local key="$1"
    if [[ -z "${COUNTERS[$key]+x}" ]];
    then
        COUNTERS[$key]=0
    fi
    COUNTERS[$key]=$(( COUNTERS[$key] + 1 ))
    printf "%05d" "${COUNTERS[$key]}"
}

# Function initkey()
# Scan destination directory once to initialize the starting sequence (max existing + 1) for a given key
# Return: void (updates MAXSEQ[key] and COUNTERS[key])
initkey()
{
    local destdir="$1" prefix="$2" segdate="$3"
    local key="${prefix}${segdate}"

    # If already initialized, nothing to do
    if [[ -n "${MAXSEQ[$key]+x}" ]]; then
        return 0
    fi

    local maxseq=0
    while IFS= read -r -d '' f; 
    do
        local bn="$(basename -- "$f")"
        if [[ "$bn" =~ ^${prefix}${segdate}-([0-9]{5})\..+$ ]]; 
        then
            local n="${BASH_REMATCH[1]}"
            n=$((10#$n))
            (( n > maxseq )) && maxseq="$n"
        fi
    done < <(find "$destdir" -maxdepth 1 -type f -name "${prefix}${segdate}-*" -print0 2>/dev/null)

    MAXSEQ[$key]="$maxseq"
    COUNTERS[$key]="$maxseq"
}

# Function namegen()
# Build a unique destination path based on prefix/date/sequence & lowercase extension
# Return: <newpath>
namegen()
{
    local dir="$1" prefix="$2" segdate="$3" extlc="$4"

    local key="${prefix}${segdate}"
    initkey "$dir" "$prefix" "$segdate"

    local seq new_name candidate
    while :; 
    do
        seq="$(nextseq "$key")"
        new_name="${prefix}${segdate}-${seq}.${extlc}"
        candidate="${dir}/${new_name}"
        [[ ! -e "$candidate" ]] && { echo "$candidate"; return 0; }
        # If exists (rare race), loop continues; with init at max+1, this is usually O(1)
    done
}

# Function classify()
# Decide IMG-/VID- prefix from extension
# Return: <prefix|empty>
classify()
{
    local extlc="$1"
    local t
    t="$(mediatype "$extlc")"
    case "$t" in
        image) echo "IMG-" ;;
        video) echo "VID-" ;;
        *) echo "" ;;
    esac
}

# Function checkduplicate()
# Handle duplicates by either deleting or moving to .duplicates
# Return: void
checkduplicate()
{
    local path="$1"
    if [[ $KEEPDUPLICATE -eq 1 ]];
    then
        local root="${OUTDIR:-$TARGETDIR}"
        local d="${root%/}/.duplicates"
        ensuredir "$d"
        local base="$(basename -- "$path")"
        local dst="${d}/${base}"
        local n=0
        while [[ -e "$dst" ]];
        do
            n=$((n+1))
            dst="${d}/${base}.${n}"
        done
        safemove "$path" "$dst" && DUPESMOVED=$((DUPESMOVED+1))
    else
        safedelete "$path" && DUPESDELETED=$((DUPESDELETED+1))
    fi
}

# Function enumfiles()
# Emit NUL-separated list of candidate files to process
# Return: <list to stdout>
enumfiles()
{
    local d="$1"
    local depth_args=(-maxdepth 1)
    [[ $RECURSIVE -eq 1 ]] && depth_args=()
    find "$d" "${depth_args[@]}" -type d -name ".duplicates" -prune -o -type f -print0 2>/dev/null
}

# Function procfile()
# Process a single file: dedupe, derive name, and rename accordingly
# Return: void
procfile()
{
    local path="$1"
    local dir file base ext extlc prefix segdate newpath
    dir="$(dirname -- "$path")"
    file="$(basename -- "$path")"
    base="${file%.*}"
    ext="${file##*.}"
    extlc="$(printf '%s' "$ext" | lower)"

    # Classify
    prefix="$(classify "$extlc")"
    [[ -z "$prefix" ]] && return 0

    # Duplicate detection
    local h
    h="$(computehash "$path")"
    if [[ -n "${HASHSEED[$h]+x}" ]];
    then
        say "DUPLICATE: \"$path\" matches \"${HASHSEED[$h]}\""
        checkduplicate "$path"
        return 0
    else
        HASHSEED["$h"]="$path"
    fi

    segdate="$(resolvseg "$path")"

    # use OUTDIR if defined
    local destdir="${OUTDIR:-$dir}"
    ensuredir "$destdir"

    newpath="$(namegen "$destdir" "$prefix" "$segdate" "$extlc")"

    if [[ "$path" == "$newpath" ]];
    then
        say "SKIP (already named): \"$path\""
        SKIPALREADY=$((SKIPALREADY+1))
        return 0
    fi

    say "RENAME: \"$file\" -> \"$(basename -- "$newpath")\""
    linebreak
    safemove "$path" "$newpath" && RENAMED=$((RENAMED+1))
    HASHSEED["$h"]="$newpath"
}

# Function execpipe()
# Enumerate and process all media files in TARGETDIR (optional recursion)
# Return: void
execpipe()
{
    local -a FILES=()
    while IFS= read -r -d '' p; do FILES+=("$p"); done < <(enumfiles "$TARGETDIR")

    local total="${#FILES[@]}"
    say "[+] Snapshot: $total files."
    say
    local idx=0

    for p in "${FILES[@]}";
    do
        idx=$((idx+1))
        PROCESSED=$((PROCESSED+1))
        local ext="${p##*.}"
        local extlc="$(printf '%s' "$ext" | lower)"
        if imgext "$extlc" || vidext "$extlc";
        then
            say "[${idx}/${total}] $p"
            procfile "$p"
        fi
    done
    say "Done. Processed: $PROCESSED files."
}

# Function main()
# Orchestrate execution of the script
# Return: void
main()
{
    local argc="$#"
    argsparser "$@"

    if [[ $argc -eq 0 ]];
    then
        showusage
        exit 0
    fi

    [[ -z "$DATEFALLBACK" ]] && DATEFALLBACK="$(currentdate)"

    if [[ ! -d "$TARGETDIR" ]];
    then
        say "ERROR: Directory not found: $TARGETDIR"
        exit 1
    fi

    if [[ -n "$OUTDIR" ]];
    then
        ensuredir "$OUTDIR" || exit 1
    fi

    if ! reqdeps;
    then
        exit 1
    fi

    showbanner
    execpipe
    showsummary
}

# Invoke callback
main "$@"