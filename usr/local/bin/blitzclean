#!/bin/bash

# VERSION - Human-readable script version string.
# Update this when making user-visible changes.
VERSION="v3.3"

# DRYRUN - When set to "1", perform a dry run only.
# Lists what would be deleted without removing anything.
DRYRUN=0

# CLEARBROWSERS - When set to "1", clean browser caches, history and configuration.
# Applies to user-level caches for Firefox and Chromium/Chrome.
CLEARBROWSERS=0

# CLEARKERNELS - When set to "1", remove old linux-image packages.
# The currently running kernel is always kept for safety.
CLEARKERNELS=0

# VACUUMDAYS - Journal retention window used by journalctl --vacuum-time.
# Older logs beyond this age will be removed.
VACUUMDAYS=7

# VACUUMSIZE - Journal size cap used by journalctl --vacuum-size.
# Journald trims logs until total size is at or below this value.
VACUUMSIZE="100M"

# TOTALBYTES - Accumulator for total bytes scheduled/removed.
# Used to report reclaimed space statistics at the end.
TOTALBYTES=0

# FRONTROOTSIZE - Free bytes on "/" measured before cleanup.
# Captured to compare space reclaimed on the root filesystem.
FRONTROOTSIZE=""

# FRONTHOMESIZE - Free bytes on $USERHOME before cleanup.
# Captured to compare space reclaimed on the home filesystem.
FRONTHOMESIZE=""

# BACKROOTSIZE - Free bytes on "/" measured after cleanup.
# Used with FRONTROOTSIZE to compute reclaimed space.
BACKROOTSIZE=""

# BACKHOMESIZE - Free bytes on $USERHOME after cleanup.
# Used with FRONTHOMESIZE to compute reclaimed space.
BACKHOMESIZE=""

# Function say()
# Execute echo with -e for consistent output formatting
# Return: <string>
say() 
{
    echo -e "$@"
}

# Function linebreak()
# Print a well formatted line break
# Return: <string>
linebreak() 
{
    printf '%0.s-' {1..100}; echo
}

# Function showbanner()
# Print the startup banner with current configuration and capability summary
# Return: void
showbanner() 
{
    clear
    printf '%0.s=' {1..60}; echo
    say "BlitzClean $VERSION - The Ultimate Ubuntu Cleanup Script"
    printf '%0.s=' {1..60}; echo
    
    say "[+] Mode $([[ $DRYRUN -eq 1 ]] && echo 'dry-run (listing only)' || echo 'real execution')"

    [[ $CLEARBROWSERS -eq 1 ]] && say "[+] Browser cache cleaning enabled"
    [[ $CLEARKERNELS -eq 1 ]] && say "[+] Kernel removal enabled"

    say "[+] Journal retention ${VACUUMDAYS} days/${VACUUMSIZE} max size"
    userpriv && say "[+] Privileges root (full cleanup)" || say "[+] Privileges user-only cleanup"
    say
    sleep 1s
}

# Function showusage()
# Print the usage menu with optional arguments
# Return: <string>
showusage() 
{
    printf '%0.s=' {1..60}; echo
    say "Usage Menu"
    printf '%0.s=' {1..60}; echo

    say "Description:"
    say "  Safely reclaim disk space on Ubuntu by cleaning caches, temp files,"
    say "  logs, Snap/Flatpak leftovers, browser caches (optional), recent-docs"
    say "  history, trash, thumbnails, and optionally old kernels."
    say
    say "Syntax:"
    say "  blitzclean [options]"
    say
    say "Options:"
    say "  --dry-run                 Preview EXACT files/paths that would be deleted."
    say "  --all                     Enable all optional features (browsers + old kernels)."
    say "  --browsers                Clean browser caches (Firefox/Chrome/Chromium/Brave)."
    say "  --kernels                 Remove old linux-image packages (keeps current kernel)."
    say "  --vacuum-days N           Journal retention by age (default: 7)."
    say "  --vacuum-size SIZE        Journal retention by size (default: 100M)."
    say "  --keep-snaps N            Keep N Snap revisions (default: 2)."
    say
    say "Help/Info:"
    say "  -h, --help, usage         Show this menu and exit."
    say "  --version                 Print version and exit."
    say
    say "Examples:"
    say "  blitzclean --dry-run"
    say "  sudo blitzclean --all"
    say "  sudo blitzclean --all --vacuum-days 7 --vacuum-size 100M --keep-snaps 2"
}

# Function showsummary()
# Print estimated bytes deleted and observed free-space deltas; finish with usage tips
# Return: void
showsummary() 
{
    echo
    printf '%0.s=' {1..60}; echo
    say "Cleanup Summary"
    printf '%0.s=' {1..60}; echo

    if [[ $DRYRUN -eq 0 ]]; 
    then
        BACKROOTSIZE=$(freebytes "/")
        BACKHOMESIZE=$(freebytes "$USERHOME")

        if [[ -n "$FRONTROOTSIZE" && -n "$BACKROOTSIZE" ]]; 
        then
            local deltaroot=$((BACKROOTSIZE - FRONTROOTSIZE))
            say "[+] Recovered: $(humansize "$deltaroot")"
        fi

        if [[ -n "$FRONTHOMESIZE" && -n "$BACKHOMESIZE" ]]; 
        then
            local deltahome=$((BACKHOMESIZE - FRONTHOMESIZE))
            say "[+] Recovered: $(humansize "$deltahome")"
        fi
    else
        say "[+] Estimated freed: $(humansize "$TOTALBYTES")"
        say "[+] Dry-run mode"
    fi
}

# Function argsparser()
# Parse the arguments passed into the script
# Return: void
argsparser() 
{
    [[ $# -eq 0 ]] && return 0

    while [[ $# -gt 0 ]];
    do
        case "$1" in
          --dry-run) DRYRUN=1; shift ;;
          --browsers) CLEARBROWSERS=1; shift ;;
          --kernels) CLEARKERNELS=1; shift ;;
          --vacuum-days) VACUUMDAYS="${2:-7}"; shift 2 ;;
          --vacuum-size) VACUUMSIZE="${2:-100M}"; shift 2 ;;
          --keep-snaps) KEEPSNAPS="${2:-2}"; shift 2 ;;
          --all) CLEARALL=1; shift ;;
          -h|--help|usage) showusage; exit 0 ;;
          --version) echo "BlitzClean v$VERSION"; exit 0 ;;
          *) echo "Unknown argument: $1"; echo; showusage; exit 1 ;;
        esac
    done

    if [[ $CLEARALL -eq 1 ]];
    then
        CLEARBROWSERS=1
        CLEARKERNELS=1
    fi
}

# Function rootcheck()
# Check if running as root (EUID=0)
# Return: <boolean>
rootcheck() 
{
    [[ $EUID -eq 0 ]]
}

# Function run()
# Prints command in dry-run otherwise executes
# Return: <cmd>
run() 
{
    if [[ $DRYRUN -eq 1 ]]; 
    then
        echo "[DRY-RUN] $*"
    else
        eval "$*"
    fi
}

# Function userpriv()
# Check if running as root (EUID=0)
# Return: <boolean>
userpriv() 
{
    [[ $EUID -eq 0 ]]
}

# Function humansize() 
# Print a human-readable size from bytes
# Return: <bytes>
humansize() 
{
    local b="$1"
    awk -v bytes="$b" '
    function human(x) {
        units="Bytes KB MB GB TB PB EB ZB YB"
        split(units, u)
        i=1
        while (x >= 1024 && i < length(u)) {
            x /= 1024
            i++
        }
        printf "%.2f %s\n", x, u[i]
    }
    BEGIN { human(bytes) }'
}

# Function addbytes()
# Safely add to the TOTALBYTES accumulator
# Return: <bytes>
addbytes() 
{
    [[ -n "$1" ]] && TOTALBYTES=$((TOTALBYTES + $1))
}

# Function freebytes()
# echo available bytes on filesystem containing <path>
# Return: <bytes>
freebytes() 
{
    local p="$1"
    df -B1 --output=avail "$p" 2>/dev/null | tail -1 | tr -d ' '
}

# Function userdir()
# Check if user directory exists in PATH
# Return: <path>
userdir() 
{
    local username homedir
    while true; 
    do
        read -rp "[?] Enter your username: " username

        if [[ -z "$username" ]];
        then
            say "[!] Username cannot be empty"
            exit 1
        fi

        homedir=$(getent passwd "$username" | cut -d: -f6)
        if [[ -z "$homedir" ]];
        then
            say "[!] User '$username' does not exist"
            exit 1
        elif [[ ! -d "$homedir" ]];
        then
            say "[!] Home directory '$homedir' for user '$username' does not exist"
            exit 1
        fi

        USERHOME="$homedir"
        break
    done
}

# Function previewlist()
# List immediate children of a directory (for dry-run)
# Return: <dir>
previewlist() 
{
    local d="$1"
    [[ -d "$d" ]] || return
    find "$d" -mindepth 1 -maxdepth 1 -print 2>/dev/null
}

# Function delfile()
# Delete a single file securely if possible
# Return: <file>
delfile() 
{
    local f="$1"
    if [[ $DRYRUN -eq 1 ]]; 
    then
        echo "$f"
        return 0
    else
        rm -f "$f"
    fi
}

# Function deldir()
# Recursively delete a directory securely if possible
# Return: <dir>
deldir() 
{
    local d="$1"
    if [[ $DRYRUN -eq 1 ]];
    then
        find "$d" -mindepth 1 -print 2>/dev/null
        return 0
    else
        rm -rf "$d"
    fi
}

# Function delpath()
# Delete a file OR the CONTENTS of a directory
# Return: <path>
delpath() 
{
    local target="$1"
    [[ -e "$target" ]] || return 0

    local size
    size=$(du -sb "$target" 2>/dev/null | awk '{print $1}')
    addbytes "${size:-0}"

    if [[ -d "$target" ]];
    then
        if [[ $DRYRUN -eq 1 ]];
        then
            previewlist "$target"
        else
            find "$target" -mindepth 1 -maxdepth 1 -print0 2>/dev/null | \
            while IFS= read -r -d '' p;
            do
                if [[ -d "$p" ]];
                then
                    deldir "$p"
                else
                    delfile "$p"
                fi
            done
        fi
    else
        delfile "$target"
    fi
}

# Function delpattern()
# Delete files matching pattern within dir
# Return: <dir> <glob>
delpattern() 
{
    local dir="$1" pattern="$2"
    [[ -d "$dir" ]] || return 0

    mapfile -t files < <(find "$dir" -maxdepth 1 -type f -name "$pattern" -print 2>/dev/null)
    [[ ${#files[@]} -eq 0 ]] && return 0

    local bytes
    bytes=$(printf '%s\0' "${files[@]}" | xargs -0 -I{} du -sb "{}" 2>/dev/null | awk '{s+=$1} END{print s+0}')
    addbytes "${bytes:-0}"

    if [[ $DRYRUN -eq 1 ]];
    then
        printf "%s\n" "${files[@]}"
    else
        printf '%s\0' "${files[@]}" | xargs -0 -r rm -f
    fi
}

# Function cleanuphome()
# Perform user-level cleanup in $USERHOME
# Return: void
cleanuphome() 
{
    linebreak
    say "[+] Cleaning $USERHOME user data"
    array=( 
        "$USERHOME/.cache/babl"
        "$USERHOME/.cache/easytag"
        "$USERHOME/.cache/gimp"
        "$USERHOME/.cache/JetBrains"
        "$USERHOME/.cache/keepassxc"
        "$USERHOME/.cache/Microsoft"
        "$USERHOME/.cache/shutter"
        "$USERHOME/.cache/sublime-text"
        "$USERHOME/.cache/thumbnails"
        "$USERHOME/.cache/totem"
        "$USERHOME/.cache/tracker3"
        "$USERHOME/.cache/ubuntu-report"
        "$USERHOME/.profile.bak"
        "$USERHOME/.shell.pre-oh-my-zsh"
        "$USERHOME/.shutter"
        "$USERHOME/.ssh"
        "$USERHOME/.thumbnails"
        "$USERHOME/.wget-hsts"
        "$USERHOME/.zcompdump"
        "$USERHOME/.zcompdump-*"
        "$USERHOME/.zshrc.bak" 
    )

    for i in "${array[@]}"
    do
        if [ -d "$i" ]; 
        then
            delpath "$i"
            rm -rf $i
        else
            delpath "$i"
        fi
    done

    trash-empty --all-users -v -f

    linebreak
    say "[+] Cleaning recent documents"
    local recentlist=(
    "$USERHOME/.local/share/recently-used.xbel"
    "$USERHOME/.cache/recently-used.xbel"
    "$USERHOME/.local/share/RecentDocuments"
    )

    for f in "${recentlist[@]}"; 
    do
        if [[ -f "$f" ]]; 
        then
            delpath "$f"
        elif [[ -d "$f" ]]; 
        then
            delpattern "$f" "*.desktop"
        fi
    done

    if [[ $CLEARBROWSERS -eq 1 ]]; 
    then
        linebreak
        say "[+] Cleaning browser caches"
        if [[ -d "$USERHOME/.mozilla/firefox" ]]; 
        then
            while IFS= read -r prof; 
            do
                delpath "$prof/cache2"
                delpath "$prof/startupCache"
            done < <(find "$USERHOME/.mozilla/firefox" -maxdepth 1 -type d -name "*.default*" 2>/dev/null)
        else
            delpath "$USERHOME/snap"
            rm -rf "$USERHOME/snap"
        fi
    
        delpath "$USERHOME/.cache/google-chrome"
        delpath "$USERHOME/.cache/chromium"
        delpath "$USERHOME/.config/google-chrome"
        delpath "$USERHOME/.config/BraveSoftware/Brave-Browser/Default/Cache"

        rm -rf "$USERHOME/.cache/google-chrome"
        rm -rf "$USERHOME/.config/google-chrome"
        rm -rf "$USERHOME/.cache/chromium"
        rm -rf "$USERHOME/.config/BraveSoftware/Brave-Browser/Default/Cache"
    fi

    linebreak
    say "[+] Cleaning $USERHOME bash history"
    cat /dev/null > "$USERHOME/.bash_history"
    cat /dev/null > "$USERHOME/.zsh_history"
    history -c && history -w
    say "$USERHOME/.bash_history"
    say "$USERHOME/.zsh_history"
}

# Function cleanupsystem()
# Perform system-wide cleanup
# Return: void
cleanupsystem() 
{
    rootcheck || return 0

    linebreak
    say "[+] Cleaning system directories"
    delpath "/tmp"
    delpath "/var/tmp"

    run "apt-get -y autoremove --purge" > /dev/null
    run "apt-get -y autoclean" > /dev/null
    run "apt-get -y clean" > /dev/null
    
    delpattern "/var/log" "*.gz"
    delpattern "/var/log" "*.[0-9]"

    run "journalctl --vacuum-time=${VACUUMDAYS}d"
    run "journalctl --vacuum-size=${VACUUMSIZE}"
    run "snap set system refresh.retain=${KEEPSNAPS}"
    if [[ $DRYRUN -eq 1 ]]; 
    then
        echo "[DRY-RUN] remove disabled snap revisions"
    else
        snap list --all 2>/dev/null | awk '/disabled|désactivé/ {print $1, $2}' | while read -r n r;
        do
            snap remove --revision="$r" "$n" --purge 2>/dev/null || true
        done
    fi

    delpattern "/var/lib/snapd/snaps" "*.old"
    run "flatpak uninstall --unused -y"
    if [[ $DRYRUN -eq 1 ]];
    then
        echo "[DRY-RUN] deborphan | xargs apt-get remove --purge -y"
    else
        deborphan 2>/dev/null | xargs --no-run-if-empty apt-get remove --purge -y
    fi
    
    if [[ $CLEARKERNELS -eq 1 ]]; 
    then
        linebreak
        local CURRENTKERNEL
        CURRENTKERNEL="$(uname -r | sed 's/-generic//')"
        say "[+] Removing old kernels (current: $CURRENTKERNEL)"
        mapfile -t OLDKERNELS < <(dpkg -l | awk '/^ii\s+linux-image-[0-9]/{print $2}' | grep -v "$CURRENTKERNEL" || true)
        for pkg in "${OLDKERNELS[@]}"; 
        do
            run "apt-get remove --purge -y $pkg"
        done
        run "update-grub"
    fi

    linebreak
    say "[+] Cleaning root data"
    array=( 
        "/root/.cache"
        "/root/.config"
        "/root/.launchpadlib"
        "/root/.ssh"
        "/root/.wget-hsts"
    )

    for i in "${array[@]}"
    do
        say "$i"
        if [ -d "$i" ]; 
        then
            rm -rf $i
        else
            rm -f "$i"
        fi
    done

    linebreak
    say "[+] Cleaning root bash history"
    sudo cat /dev/null > "/root/.history"
    history -c && history -w
    say "/root/.history"
}

# Function main()
# Orchestrate execution of the script
# Return: void
main() 
{
    set -o pipefail

    argsparser "$@"
    userdir
    showbanner

    FRONTROOTSIZE=$(freebytes "/")
    FRONTHOMESIZE=$(freebytes "$USERHOME")

    cleanuphome
    cleanupsystem
    showsummary
}

# Invoke callback
main "$@"